
MRI Toolbox (MRIT)
written by Haisam Islam (nimbuszero@gmail.com)

+ Table of Contents ============================================================ [0]

  1. About
  2. Setup
  3. Getting Started
  4. Notes on Parameters
  5. Contents

+ About ======================================================================== [1]

  The MRI Toolbox is a library of tools for MRI, which include gradient waveform
  generation, RF pulse design, image reconstruction, data visualization, and
  other miscellaneous tools. I developed these tools during my PhD at Stanford
  University, but they are not related specifically to my research, but more to
  general MRI sequence development. The library is organized into the different
  folders, which are listed below along with a brief description of each's
  contents. A more detailed description, including certain functions found in
  each folder, is found in the Contents section.

  folder        description
  ------------------------------------------------------------------------------
  demo          demos for various tools found in the library
  disp          tools for displaying data
  g             tools for generating gradient waveforms
  recon         tools for reconstructing images
  rf            tools for generating rf pulses
  util          various utility functions

+ Setup ======================================================================== [2]

  To setup the MRIT library, add the 'mrit' folder to the matlab path. The
  'startup.m' file then gets executed automatically when matlab starts up, and
  adds the various folders in the library to the matlab path.

  Also, run the 'setup.m' script. This needs to be done only once, and performs
  initializations such as compiling mex functions.

  There are some other libraries (listed below) that may be useful to you.
  These are used by some of the functions in this library if certain options are
  specified, but for the most part, are not needed. All the included demos will
  work without these libraries.

  rf_tools : https://github.com/agentmess/Spectral-Spatial-RF-Pulse-Design
  This includes various tools for RF pulse design, written by John Pauly.

  MIRT : https://web.eecs.umich.edu/~fessler/irt/fessler.tgz
  This includes a wide range of tools for MRI, written by Jeff Fessler's group
  in the University of Michigan.

+ Getting Started ============================================================== [3]

  After setting up the library, a good place to start is the 'demo' folder,
  which contains scripts that showcase the various tools found in this library.
  You can start by running these scripts and looking at their contents to see
  how the functions are used. Refer to the documentation for each function to
  see what parameters are expected, as well as any optional parameters. Most
  of the larger functions contain multiple optional parameters with default
  values. The section 'Notes on Parameters' covers details about how parameter
  information is provided in the documentation, and other important information.

+ Notes on Parameters ========================================================== [4]

  The help section for each function specifies various things about each
  parameter, such as the data structure (e.g. scalar, vector, array, struct,
  ...), the data type (e.g. int, float, complex, string, ...), the units
  for the data (e.g. cm, ms, G, G/cm, ...), or the specific values that the
  parameter can take (e.g. 0 or 1). Not all these need to be specified, however,
  since certain information can be assumed based on the given information. The
  various pieces of information can be specified as follows:

  [] indicates an array, with the contents inside specifying what each dimension
  is, e.g. [x y time] indicates a 3D array with dimensions x, y, and time. The
  size of the array is then [#x #y #time] where the # indicates the number of
  points along the given dimension. However, the size of a dimension is
  sometimes explicitly specified in {} next to the dimension name, e.g.
  [x y{#x/2} time{4}] means the y dimension is 1/2 the size of the x dimension,
  and the time dimension is of size 4.

  An arbitrary number of dimensions is indicated by '...' after the dimensions,
  e.g. [x y time ...] means there can be an arbitrary number of dimensions after
  the time dimensions, i.e. the total number of dimensions is >= 3.

  If the data is one dimensional, it is simply specified as (vector). If the
  vector is of a particular length N, it is written as N-vector, e.g. 2-vector.

  The units or data type are given in (). If the units are specified, then the
  data type can usually be assumed, e.g.  units of 'cm' indicates float data.
  Otherwise, the data type can be explicitly given. The various units include:
  int, float, complex, string, logical, etc...
  By default, if the units are not specified, they are assumed to be float.

  Sometimes, a parameter can take only one of certain values. In such cases, the
  various values it can take are given in <>, e.g. a parameter that can either
  be 0 or 1 is indicated by <0, 1>. In some cases, what these values mean need
  to be specified, which is done by listing them in the following lines,e.g.
    0 : false
    1 : true

  ..............................................................................

  Most of the functions contain optional parameters that can be specified after
  the list of required parameters. These are specified in the following way.
  For each optional parameter, two parameters need to be passed: the name of the
  parameter (passed as a string), and the value. For example, to add an overlay
  for the 'imdisp' function, you would do: imdisp(underlay, 'o', overlay);

+ Contents ===================================================================== [5]

  demo -------- demos for various functions in the library ---------------------
  go_fmri       processes fMRI data using a general linear model, and displays
                the activation maps.
  go_hs         designs an adiabatic hyperbolic-secant RF pulse, plots the
                response, and displays the Bloch evolution of the magnetization.
  go_pi         takes multichannel DFT data, undersamples it, and reconstructs
                it using GRAPPA and SENSE.
  go_reconepi   reconstructs EPI data from a uniform agar phantom.
  go_reconepilg reconstructs EPI data from an agar phantom with a large
                off-resonance gradient across it. There are many options for
                the reconstruction: acceleration factor (GRAPPA or SENSE),
                Nyquist ghost correction method, field map correction. If
                GRAPPA is used, there are other options that can be specified.
  go_rfepi      generates an EPI RF pulse for exciting a rectangular region of
                a given size with a given selectivity, and displays the
                response.
  go_spsp       generates spatial-spectral RF pulses (flyback and no flyback)
                and displays the responses.

  disp -------- tools for displaying data --------------------------------------
  cycplot       allows you to cycle through multiple plots with the arrow keys.
  imdisp        displays an N-D array of slices, where the first two dimensions
                contain the slices (similar to matlab's 'montage').
  mplot         like matlab's 'plot', but allows you to specify multiple plot
                properties in one line, and has (in my opinion) better defaults.
  show4d        displays 4-D data (x, y, z, time) in an interactive GUI. useful
                for visualizing e.g. fMRI data.

  fmri -------- tools for analyzing fmri data ----------------------------------
  hrf.mat       contains a canonical hemodynamic response function.
  bdcov         creates a block-design stimulus covariate.
  cstat         converts between p-values, correlation values, and t-scores,
                accounting for the auto-correlation of the hemodynamic response
                function.
  glm           performs a general linear model, with inputs for stimulus and
                nuisance covariates, with polynomial detrending.
  pfilt         uses an adaptive low-pass filter to improve the SNR, but uses
                the local standard deviation to preserve edges.
  tsdf          computes the effective # degrees of freedom in a time-series,
                accounting for the auto-correlation of the hemodynamic response
                function.

  g ----------- tools related to gradient design -------------------------------
  gepi          generates an EPI trajectory.
  gtrap         generates a trapezoid, with options to minimize the length for
                a given area, maximize the area for a given length, or create
                a trapezoid with a given length and area.

  recon ------- tools for reconstructing mri data ------------------------------
  cbo           calculates the B0 field map using two complex images at
                different echo times. this is fast, but doesn't produce the 
                cleanest maps - the 'mri_sensemap_denoise' function in the 'irt'
                toolbox works much better (see the Links section).
  epifmc        performs time-segmented field-map correction on EPI data -
                requires a B0 field map.
  grap2coef     computes 2D GRAPPA coefficients using a fully sampled region of
                k-space and a kernel mask.
  grap2dft      fills in missing lines of k-space using GRAPPA.
  grap2fill     fills in missing 2D k-space entries using GRAPPA coefficients.
  repi          reconstructs ramp-sampled EPI data, performing phase correction
                using a reference scan, with options for GRAPPA.
  sense         performs a SENSE reconstruction.

  rf ---------- tools related to rf pulse design -------------------------------
  bloch         simulates the response to an RF pulse and set of gradients, with
                support for up to 3 gradient axes.
  getfa         gets flip angle for a complex RF pulse.
  rfepi         generates a 2D EPI RF pulse for exciting a rectangular region.
  rfhs          generates a hyperbolic-secant RF pulse.
  spsp          generates a spatial-spectral RF pulse.
  verse         reshapes an RF pulse based on the applied gradient so that the
                deposited B1 weighting matches the original RF pulse.
  viewbloch     allows you to visualize the evolution of the magnetization as
                the RF pulse and gradients are applied.
  viewslpr      handy tool to visualize overlap of adjacent slices with a given
                slice thickness, spacing, and time-bandwidth of a given
                slice-select RF pulse.
  wsinc         generates a hamming-weighted sinc RF pulse.

  util -------- various utility functions --------------------------------------
  ccfilt2       convenience tool for filtering connected components.
  fwhm          computes the full-width at half-max and offset of a curve.
  mask          generates a mask based on the intensity histogram.
  nufft{1,2}    a non-uniform FFT in (1 or 2) dimensions (for reconstructing
                data not sampled on a grid).
  pfit          computes polynomial fit coefficients (has some extra features
                over matlab's 'polyfit').
  setopts       useful tool for setting default values for arguments.

  There are other functions in the various folders that are not listed here
  since they are mostly small utility functions.

